# An example of Exam question solved in EPL

## Introductions

Suppose you want to monitor with a stream processing engine a group of robots used for picking and placing goods in an Industry 4.0 storehouse.
Each robotic arm sends events reporting its status: 

* ready to pick the good, 
* good grasped, 
* moving the good, 
* placing the good, 
* moving without any good. 

Several Force-Sensing Resistors measure the stress levels of the robotic arm. If the stress level is between 0 and 6, the robot is safely operating. If it is between 7 and 8, a controller should raise a warning. If it is above 9, a controller should stop the robot.

## Questions & answers

### E1

Propose how to model the streaming data generated by the robotic arms.

#### Some thinking

There are two forces: the **reality** and the **pragmatism**

The **reality** pushes for the most detailed model. Notably, the text above may imply that the Force-Sensing Resistors are independent sensor and they send their own events separately from the arms. So one may be tempted to propose the following modeling.

```
create schema RoboticArm(id int, status string); 
create schema ForceSensingResistors(idArm string, stressLvl int)
```

The **pragmatism** on the contrary pushes for the minimum model that allows to continuously process the data so to satisfy the needs presented in the following point (from E2 to E5). If you read them, you may understand that they require a much simpler model:

```
create schema RoboticArm( id string, status string, stressLevel int );
```

The rest of the proposed solution follows the pragmatic approach

#### A best practice

A best practice that I recommend is to always write down a portion of the stream modelled according to your design choice.

For instance:

```
RoboticArm={id="1", status="ready", stressLevel=0} 
t=t.plus(1 seconds) 
RoboticArm={id="1", status="goodGrasped", stressLevel=1} 
t=t.plus(1 seconds) 
RoboticArm={id="1", status="movingGood", stressLevel=7} 
RoboticArm={id="2", status="ready", stressLevel=0} 
t=t.plus(1 seconds) 
RoboticArm={id="2", status="goodGrasped", stressLevel=5} 
t=t.plus(1 seconds) 
RoboticArm={id="2", status="movingGood", stressLevel=9} 
t=t.plus(5 seconds) 
RoboticArm={id="2", status="placingGood", stressLevel=3} 
RoboticArm={id="1", status="placingGood", stressLevel=3} 
t=t.plus(4 seconds) 
RoboticArm={id="1", status="moving", stressLevel=2} 
RoboticArm={id="2", status="moving", stressLevel=1} 
t=t.plus(3 seconds) 
RoboticArm={id="1", status="ready", stressLevel=0} 
RoboticArm={id="2", status="ready", stressLevel=0} 
t=t.plus(1 seconds)
```

Another best practice is to always state your assumptions:

* the arm sends and event only when it changes status
* the status can only appear in the order listed in the text above
* if the arm stops due to a fault it does not send any event
* the an arm restarts after a fault it is always in the status ready
* the stress level in each event is the maximum the arm experienced during between the reported status and the previous one

### E2 

Write a continuous query that emits the max stress for each arm.

#### Solution

```
@Name("E2") 
SELECT id, max(stressLevel) 
FROM RoboticArm 
GROUP BY id;
```

### E3 

A continuous query that emits the average stress level between a pick (status==goodGrasped) and a place (status==placingGood). 

HINT: some times you cannot compute an average using the aggregate operator `avg`

#### Solution

```
@Name("E3") 
SELECT a.id, (a.stressLevel + b.stressLevel + c.stressLevel) / 3
FROM pattern [ 
	every 	a=RoboticArm(status="goodGrasped") -> 
		  	b=RoboticArm(id = a.id, status="movingGood") ->
		  	c=RoboticArm(id = a.id, status="placingGood")  ];
```

### E4

A continuous query that returns the robotic arms that, 

* in less than 10 second,
* picked a good while safely operating,
* moved it while the controller was raising a warning, and
* placed it while safely operating again.

#### Solution

```
@Name("E4") 
insert into warning
SELECT a.id 
FROM pattern [ 
	every	a=RoboticArm(status="goodGrasped", stressLevel < 7) ->
			(
				b=RoboticArm(id = a.id, status="movingGood", stressLevel > 6 and stressLevel < 9) ->
				c=RoboticArm(id = a.id, status="placingGood", stressLevel < 7) 
			)
			where timer:within(10 seconds)
		] ;
```

### E5

A continuous query that monitors the results of the previous one (i.e., E4) and counts how many times each robotic arm is present in the stream over a window of 10 seconds updating the counting every 2 seconds.

#### Solution

```
@Name("E5") 
select arm, count(*)
from warning.win:time(10 sec)
group by arm
output last every 2 sec;
```

## Bonus content

### relaxing assumptions

#### what if the arm does not send and event only when it changes status

for instance, it may report moving goods multiple times such as in 

```
RoboticArm={id="1", status="ready", stressLevel=0} 
t=t.plus(1 seconds) 
RoboticArm={id="1", status="goodGrasped", stressLevel=1} 
t=t.plus(1 seconds) 
RoboticArm={id="1", status="movingGood", stressLevel=7} 
RoboticArm={id="2", status="ready", stressLevel=0} 
t=t.plus(1 seconds) 
RoboticArm={id="1", status="movingGood", stressLevel=7} 
RoboticArm={id="2", status="goodGrasped", stressLevel=5} 
t=t.plus(1 seconds) 
RoboticArm={id="2", status="movingGood", stressLevel=9} 
t=t.plus(5 seconds) 
RoboticArm={id="2", status="placingGood", stressLevel=3} 
RoboticArm={id="1", status="placingGood", stressLevel=3} 
t=t.plus(4 seconds) 
RoboticArm={id="1", status="moving", stressLevel=2} 
RoboticArm={id="2", status="moving", stressLevel=1} 
t=t.plus(3 seconds) 
RoboticArm={id="1", status="ready", stressLevel=0} 
RoboticArm={id="2", status="ready", stressLevel=0} 
t=t.plus(1 seconds)
```

Is E4 solution still valid? Shall we add a new every clause somewhere?

Adding `every` in front of `b=RoboticArm(id = a.id, status="movingGood", stressLevel > 6 and stressLevel < 9)` makes a difference

```
@Name("E4.every") 
insert into warning
SELECT a.id 
FROM pattern [ 
	every	a=RoboticArm(status="goodGrasped", stressLevel < 7) -> 
			(  
				every b=RoboticArm(id = a.id, status="movingGood", stressLevel > 6 and stressLevel < 9) ->
				c=RoboticArm(id = a.id, status="placingGood", stressLevel < 7) 
			)
			where timer:within(10 seconds)
		] ;
```

#### What if the control system sends a stop event when an arm has a fault

extra event type

```
create schema Stop( id string);
```

data that contains it making the alternative assumption that arms restarts after a fault in the status they where before the fault. 

```
RoboticArm={id="1", status="ready", stressLevel=0} 
t=t.plus(1 seconds) 
RoboticArm={id="1", status="goodGrasped", stressLevel=1} 
t=t.plus(1 seconds) 
RoboticArm={id="1", status="movingGood", stressLevel=7} 
RoboticArm={id="2", status="ready", stressLevel=0} 
t=t.plus(1 seconds) 
RoboticArm={id="2", status="goodGrasped", stressLevel=5} 
t=t.plus(1 seconds) 
RoboticArm={id="2", status="movingGood", stressLevel=9} 
t=t.plus(2 seconds) 
Stop={id="1"}
t=t.plus(3 seconds) 
RoboticArm={id="2", status="placingGood", stressLevel=3} 
RoboticArm={id="1", status="placingGood", stressLevel=3} 
t=t.plus(4 seconds) 
RoboticArm={id="1", status="moving", stressLevel=2} 
RoboticArm={id="2", status="moving", stressLevel=1} 
t=t.plus(3 seconds) 
RoboticArm={id="1", status="ready", stressLevel=0} 
RoboticArm={id="2", status="ready", stressLevel=0} 
t=t.plus(1 seconds)
```

In that case, E4 may be updated as follows to avoid creating a warning if the arm stops while moving.

```
@Name("E4.andnot") 
insert into warning
SELECT a.id 
FROM pattern [ 
	every	a=RoboticArm(status="goodGrasped", stressLevel < 7) -> 
			(  every
				b=RoboticArm(id = a.id, status="movingGood", stressLevel > 6 and stressLevel < 9) ->
				c=RoboticArm(id = a.id, status="placingGood", stressLevel < 7) and not Stop(id = a.id)
			)
			where timer:within(10 seconds)
		] ;
```

NOTE: if you remove the Stop event, E4.andnot matches once. With the Stop event, it does not match.

### understanding parenthesis and `where timer:within`

```
create schema A (
n int
);

create schema B (
n int
);

create schema C (
n int
);

@name("experiment.0")
select a.n, b.n, c.n
from pattern [
a=A -> b=B -> c=C where timer:within(1 sec)
];

@name("experiment.1")
select a.n, b.n, c.n
from pattern [
a=A -> b=B -> c=C where timer:within(2 sec)
];

@name("experiment.2")
select a.n, b.n, c.n
from pattern [
a=A -> (b=B -> c=C) where timer:within(2 sec)
];

@name("experiment.3")
select a.n, b.n, c.n
from pattern [
a=A -> (b=B -> c=C) where timer:within(3 sec)
];
```

using

```
A={n=1} 
t=t.plus(1 seconds) 
B={n=1} 
t=t.plus(1 seconds) 
C={n=1}
```

the answer are

```
At: 2001-01-01 08:00:02.000

    Statement: experiment.1
        Insert
            experiment.1-output={a.n=1, b.n=1, c.n=1}
    Statement: experiment.3
        Insert
            experiment.3-output={a.n=1, b.n=1, c.n=1}
```

NOTE: Only experiment.1 and experiment.3 match.

